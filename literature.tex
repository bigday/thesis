\chapter{Related work}

\fixme{Refer to relevant sources a topic at a time}

% libraries
% \citep{OpenNI} \citep{NITE} \citep{PCL}
\section{Point cloud alignment} \label{literature.alignment}

\fixme{mention rigid and non-rigid registration}

\fixme{Why is point cloud alignment interesting?}

The Iterative Closest Point (ICP) algorithm is commonly used for aligning two point clouds. \fixme{The algorithm was originally presented by \citet{besl1992method} and \citet{chen1991object}} The algorithm in pseudocode is shown in Algorithm \ref{literature.pseudoicp}. It works by finding corresponding points from the two point clouds. Then a rigid transformation that minimizes the error between the corresponding point pairs is searched for. This transformation is then applied. Iterating this multiple times, a local optimum should be found.

\begin{algorithm}
\caption{Iterative Closest Point}
\label{literature.pseudoicp}
\begin{algorithmic}
    \For{1..iterations}
        \ForAll{point $x_i$ in X}
            \State $y_i$ = closest point in Y
        \EndFor
        \State error := $sum_i (x_i-y_i)^2$
        \State find rigid transformation $T_i$ that minimizes error
        \State apply $T_i$ on X
    \EndFor
    \State \Return output T = $product_i T_i$
\end{algorithmic}
\end{algorithm}

Even from this description it's obvious that ICP has its shortcomings. If the initial guess is too much off, the algorithm can yield bad results. This is because for non-trivial point clouds, local optima may exist that are significantly different from the global optimum.

Another issue with ICP is that it requires a lot of computation if the point clouds are large. \citet{rusinkiewicz2001efficient} review different ways of improving the efficiency of ICP. They also attain minor improvements to the alignment accuracy.

However, even these improved variants of ICP suffer from converging on local minima. The EM-ICP \fixme{(abbreviation)} algorithm introduced by \citet{granger2006multi} overcomes this problem \fixme{at the cost of being computationally very intensive. (is this accurate?)}

\citet{tamaki2010softassign} make EM-ICP more efficient by implementing the computation on GPU using CUDA. The speed is unfortunately still not fast enough for real-time usage on current hardware.

Another interesting improvement over ICP is suggested by \citet{tykkala2011direct}. Their algorithm, Direct Iterative Closest Point, is very well suited for Simultaneous Localization and Mapping (SLAM) using an RGB-D sensor. Direct ICP stores all data in 2D images, thus avoiding expensive 3D nearest neighbor searches. This makes it computationally much cheaper than traditional ICP. The change in approach from 3D point coordinate matching to computing transformations between 2D images also enables using RGB as well as depth data for computation. Using both simultaneously can make the algorithm more robust and accurate. This is demonstrated for deriving the trajectory and pose of a moving camera in static scenery. The downside is that a balancing factor $\lambda$ between the visual and depth data needs to be chosen.

\citep{chui2003new} TPS-RPM \citep{yang2011thin}
\citep{huang2011visual} FOVIS\footnote{\url{http://code.google.com/p/fovis}}


\section{Human body models}
\citep{anguelov2005scape}
\citep{baek2012parametric}

\subsection{MakeHuman}

\fixme{should this be here?}

MakeHuman\footnote{\url{http://www.makehuman.org/}} is an open source software application for 3D human modeling.

MakeHuman has an androgynous base mesh that supposedly depicts an average human. It can be modified in diverse ways using a number of predefined `targets,' i.e. deformations. A commendable amount of work has been put into refining the base mesh and targets. Initially it seems like an arbitrary human could be accurately modeled using MakeHuman, given enough time for fine-tuning.

\section{3D reconstruction}
(generic)
\citep{fabio2003point}

(human mesh)

Currently, the most promising work at creating personalized human avatars has been by \citet{weiss2011home}. Their approach uses the SCAPE body model \citep{anguelov2005scape}. This makes for very good reconstruction accuracy and excellent \fixme{rendered shapes (muscle deformation according to pose etc)}. However, the evaluation is slow\fixme{ at x seconds per frame (or somesuch)} and the SCAPE model needs to be trained with a large amount of data beforehand.

\citep{schneider2010fitting}
\citep{ahmed2005automatic}
\citep{tongscanning}
\citep{charpentier2011accurate}
\citep{hirshbergc2011evaluating}

(human pose)
\citep{baak2011data}

\section{KinectFusion}

KinectFusion is a real-time 3D reconstruction system that uses data from a moving Kinect sensor. It performs camera position and pose tracking, surface reconstruction and rendering. \citep{izadi2011kinectfusion}

The implementation works on consumer hardware by way of general-purpose computing on graphics processing units (GPGPU). More specifically, KinectFusion utilizes fully parallel tracking and mapping algorithms that are very efficient on the GPU (graphics processing unit) \citep{newcombe2011kinectfusion}.

\fixme{KinectFusion technology: raycasting, ICP, TSDF/voxel grid}

\fixme{KinectFusion uses a variation of Signed Distance Function (SDF), whose value is defined as the distance to the nearest surface for a point in space. The values are signed--a negative value means the point is inside an object. In the KinectFusion implementation, a 3D volume of fixed physical dimensions and resolution is allocated. For each cell in this voxel grid, the distance to nearest surface is saved. However, only values for a truncated area near the surface are actually stored--this variation is called Truncated Signed Distance Function (TSDF). \citep{izadi2011kinectfusion}}

KinectFusion was made in a project at Microsoft Research. No source code has been published. Nevertheless, an open source implementation called Kinfu has been made based on the descriptions in the two articles. Kinfu is available as part of the Point Cloud Library (PCL) \citep{PCL}.

The availability of an open source implementation has allowed further improvements on the system. For example, the KinectFusion algorithm was soon improved to work over extended areas \citep{Whelan12rssw}. The enhanced version is called Kintinuous and has been built on Kinfu. The authors have pledged to release the source code back to PCL \fixme{(citation)}, but as of writing this has not yet happened.

\fixme{Kintinuous: moving TSDF, FOVIS; improvements: ICP+RGBD+FOVIS etc}

Later on, Kintinuous has been further improved. 
\citep{Whelan12tr}

